---
published: true
title:   "TIL-21 : JS - Promise.all()"
excerpt: "Today I Learned JS Promise.all !"

categories:
    - Study
tags:
    - JS

toc: true
toc_label: "목차"
toc_icon: "bars"
toc_sticky: true

comments: true

date: 2023-06-01
last_modified_at: 2023-06-01
---
<br>

## 비동기 처리를 위한 Promise.all() 메서드

복수의 API 요청을 보내고, 모든 응답을 받아 결과를 처리해야 할 때, 어떤 방식으로 처리하는 것이 좋을까요?

일단, 1차원적인 생각으로 처리를 한다고 하면 아마 아래와 같은 방법을 생각할 수 있습니다.

```jsx
// 5개의 API를 요청하고 응답 받는다.
1. 첫 번째 API 요청...
==== 서버에서 요청 처리중...(n ms) ====
2. 첫 번째 API 응답...
3. 두 번째 API 요청...
==== 서버에서 요청 처리중...(n ms) ====
4. 두 번째 API 응답...
5. 세 번째 API 요청...
==== 서버에서 요청 처리중...(n ms) ====
6. 세 번째 API 응답...

... 반복

11. 전체 응답 결과 확인 후 후 처리 (Total n ms)...
```

이런 식으로 요청을 보내고 →  처리 시간을 기다리고 → 응답을 받고 반복을 하게 됩니다.

이렇게 로직을 구현한 경우 마지막에 이 로직을 처리하기 위해선 5번의 처리 시간을 합산한 시간만큼 로딩이 걸리게 됩니다.

위와 같은 로직은 사용자가 많은 시간을 기다리게 되고 좋은 로직이라고 볼 수 없으며, 성능 개선이 필요한 로직이라고 생각됩니다.

그렇다면 어떻게 하면 좋을까요?🤔

5개의 API 요청을 동시에 보낸 뒤, 각각 비동기 처리를 통해 마지막으로 응답이 들어오면 후처리를 하는 것이 효율적이라고 볼 수 있습니다.

이런 상황에서 사용할 수 있는 메서드가 바로 `Promise 클래스`의 `all()` 입니다.

```jsx
const req = Promise.all([Promise 배열])
```

> **`Promise`** 객체는 비동기 작업이 맞이할 미래의 완료 또는 실패와 그 결과 값을 나타냅니다.
> 

all() 파라미터로 API 호출을 위한 복수의 Promise들이 `배열` 형태로 들어가게 됩니다.

배열의 각 Promise가 실행되고, 각각의 결과값을 받아 처리하는 새로운 Promise가 실행됩니다.
실행 결과로 각 Promise의 결과값을 배열안에 담아 반환하는 로직을 실행합니다.

`Promise.all()`은 각각의 요청을 `비동기`로 처리하기 때문에 서버에서 처리되는 순서가  Promise 배열의 순서와 일치하지 않을 수 있습니다. 순서를 보장하지 않습니다.

다만 결과값을 담는 배열의 경우 Promise의 순서대로 결과값이 들어갑니다.
⇒ index 0의 요청이 가장 마지막에 완료되어도 결과 배열에는 원래 자리인 0번에 들어가게 됩니다.

때문에 이 all()을 활용하면 여러 개의 비동기 처리를 한번에 할 수 있지만 문제점 같은 주의사항이 있습니다.

이 Promise들 중 하나라도 요청 실패로 error가 발생하면 `reject`이 되고, 전체 Promise들이 reject 된다는 점입니다. 그렇기 때문에 all을 사용할 경우 예외처리를 신중하게 해야한다는 주의사항이 있습니다.